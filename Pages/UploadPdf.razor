@page "/upload-pdf"
@using WordPressPCL
@using WordPressPCL.Models
@using System.IO
@using Microsoft.AspNetCore.Components.Forms
@inject IJSRuntime JS
@inject AuthMessageHandler AuthHandler

<PageTitle>Upload PDF</PageTitle>

<h1>Upload PDF</h1>

@if (client == null)
{
    <p>No WordPress endpoint verified. Visit <NavLink href="/">Home</NavLink> first.</p>
}
else
{
    <div class="mb-3">
        <InputFile id="file-input" class="form-control" accept="application/pdf" OnChange="HandleFileChange" />
    </div>
    <div class="d-flex align-items-center gap-2 mb-3">
        <button id="upload-btn" class="btn btn-primary" @onclick="UploadAsync" disabled="@(_file == null)">Upload to WordPress</button>
        @if (!string.IsNullOrEmpty(status))
        {
            <span>@status</span>
        }
    </div>
    @if (isUploading)
    {
        <div class="progress mb-3">
            <div class="progress-bar" role="progressbar" style="width: @uploadProgress%" aria-valuenow="@uploadProgress" aria-valuemin="0" aria-valuemax="100">@uploadProgress%</div>
        </div>
    }
    <canvas id="canvas" style="display:none;"></canvas>
    <div class="preview-wrapper">
        <img id="preview" class="preview-image mb-3" alt="PDF preview" />
    </div>
}

<script type="module">
    import * as pdfjsLib from './libman/pdfjs-dist/build/pdf.mjs';
    pdfjsLib.GlobalWorkerOptions.workerSrc = './libman/pdfjs-dist/build/pdf.worker.mjs';

    const cMapBaseUrl = './libman/pdfjs-dist/cmaps/';
    const cMapPacked = true;

    const { getDocument } = pdfjsLib;
    const fileInput = document.getElementById('file-input');
    const canvas = document.getElementById('canvas');
    const outputImg = document.getElementById('preview');
    const uploadBtn = document.getElementById('upload-btn');
    let previewDataUrl = '';

    function adjustPreview() {
        if (!outputImg) return;
        const rect = outputImg.getBoundingClientRect();
        const top  = rect.top + window.scrollY;
        const h    = window.innerHeight - top - 20;
        outputImg.style.maxHeight = h + 'px';
    }

    window.addEventListener('resize', adjustPreview);

    outputImg?.addEventListener('load', adjustPreview);

    fileInput?.addEventListener('change', async () => {
        const file = fileInput.files[0];
        if (!file) return;

        const arrayBuffer = await file.arrayBuffer();
        const loadingTask = getDocument({
            data: arrayBuffer,
            cMapUrl: cMapBaseUrl,
            cMapPacked
        });
        const pdf = await loadingTask.promise;

        const page = await pdf.getPage(1);
        const viewport = page.getViewport({ scale: 2 });

        canvas.width = viewport.width;
        canvas.height = viewport.height;
        const ctx = canvas.getContext('2d');
        await page.render({ canvasContext: ctx, viewport }).promise;

        previewDataUrl = canvas.toDataURL('image/png');
        outputImg.src = previewDataUrl;
        adjustPreview();
    });
    window.getPreviewDataUrl = () => previewDataUrl;
</script>

@code {
    private WordPressClient? client;
    private IBrowserFile? _file;
    private string? status;
    private int uploadProgress;
    private bool isUploading;

    protected override async Task OnInitializedAsync()
    {
        var endpoint = await JS.InvokeAsync<string?>("localStorage.getItem", "wpEndpoint");
        if (string.IsNullOrEmpty(endpoint))
        {
            return;
        }
        var baseUrl = endpoint.TrimEnd('/') + "/wp-json/";
        var httpClient = new HttpClient(AuthHandler) { BaseAddress = new Uri(baseUrl) };
        client = new WordPressClient(httpClient);
    }

    private void HandleFileChange(InputFileChangeEventArgs e)
    {
        _file = e.File;
    }

    private async Task UploadAsync()
    {
        if (client == null || _file == null)
        {
            return;
        }

        status = null;
        uploadProgress = 0;
        isUploading = true;
        try
        {
            var previewUrl = await JS.InvokeAsync<string>("getPreviewDataUrl");
            byte[] previewBytes = Array.Empty<byte>();
            if (!string.IsNullOrEmpty(previewUrl))
            {
                var commaIndex = previewUrl.IndexOf(',');
                if (commaIndex >= 0)
                {
                    previewUrl = previewUrl[(commaIndex + 1)..];
                }
                previewBytes = Convert.FromBase64String(previewUrl);
            }

            var previewFileName = Path.GetFileNameWithoutExtension(_file.Name) + ".png";
            MediaItem? previewMedia = null;
            if (previewBytes.Length > 0)
            {
                using var previewStream = new MemoryStream(previewBytes);
                previewMedia = await client.Media.CreateAsync(previewStream, previewFileName, "image/png");
            }

            using var stream = _file.OpenReadStream(long.MaxValue);
            using var progressStream = new ProgressStream(stream, (sent, total) =>
            {
                uploadProgress = (int)(sent * 100 / total);
                InvokeAsync(StateHasChanged);
            });
            var pdfMedia = await client.Media.CreateAsync(progressStream, _file.Name, "application/pdf");

            if (previewMedia != null)
            {
                var post = new Post
                {
                    Title = new Title(Path.GetFileNameWithoutExtension(_file.Name)),
                    Content = new Content($"<a href=\"{pdfMedia.SourceUrl}\">{_file.Name}</a>"),
                    Status = Status.Publish,
                    FeaturedMedia = previewMedia.Id
                };
                var created = await client.Posts.CreateAsync(post);
                status = $"Uploaded post ID: {created.Id}";
            }
            else
            {
                status = $"Uploaded media ID: {pdfMedia.Id}";
            }
            uploadProgress = 100;
        }
        catch (Exception ex)
        {
            status = $"Error: {ex.Message}";
        }
        finally
        {
            isUploading = false;
        }
    }
}
