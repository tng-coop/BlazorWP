
@page "/edit-demo"
@using TinyMCE.Blazor
@inject IJSRuntime JS
@implements IAsyncDisposable

<PageTitle>Edit Demo</PageTitle>

<h1>Edit Demo</h1>

<div class="mb-3">
  <button class="btn btn-primary me-1" @onclick="() => SelectDoc(Doc.A)">Document A</button>
  <button class="btn btn-primary me-1" @onclick="() => SelectDoc(Doc.B)">Document B</button>
  <button class="btn btn-primary"      @onclick="() => SelectDoc(Doc.C)">Document C</button>
</div>

<Editor
  Id="demoEditor"
  ScriptSrc="libman/tinymce/tinymce.min.js"
  LicenseKey="gpl"
  JsConfSrc="myTinyMceConfig"
  @bind-Value="currentText"
  @bind-Value:after="OnContentChanged"  
  />

<div class="row mt-3">
  <div class="col">
    <label>Document A</label>
    <textarea class="form-control" rows="5" readonly @bind="docA"></textarea>
  </div>
  <div class="col">
    <label>Document B</label>
    <textarea class="form-control" rows="5" readonly @bind="docB"></textarea>
  </div>
  <div class="col">
    <label>Document C</label>
    <textarea class="form-control" rows="5" readonly @bind="docC"></textarea>
  </div>
</div>

<div class="row mt-1">
  <div class="col">
    <label>Events</label>
    <textarea class="form-control" rows="5" readonly>@eventLogText</textarea>
  </div>
</div>

@code {
  private enum Doc { A, B, C }
  private Doc currentDoc = Doc.A;

  private string currentText = string.Empty;
  private string docA = string.Empty;
  private string docB = string.Empty;
  private string docC = string.Empty;

  private const string KeyDocA = "editDemoDocA";
  private const string KeyDocB = "editDemoDocB";
  private const string KeyDocC = "editDemoDocC";

  private DateTime lastSaveTime = DateTime.UtcNow;
  private bool saveScheduled = false;
  private CancellationTokenSource? saveCts;

  // capture all events
  private List<string> eventLog = new();
  private string eventLogText => string.Join("\n", eventLog);

  protected override void OnInitialized() {
    currentText = docA;
  }

  private void SelectDoc(Doc doc) {
    SaveCurrent();
    currentDoc = doc;
    currentText = GetCurrent();
  }

  private void SaveCurrent() {
    switch (currentDoc) {
      case Doc.A: docA = currentText; break;
      case Doc.B: docB = currentText; break;
      case Doc.C: docC = currentText; break;
    }
  }

  private string GetCurrent() => currentDoc switch {
    Doc.A => docA,
    Doc.B => docB,
    Doc.C => docC,
    _ => string.Empty
  };

  private void OnContentChanged() {
    SaveCurrent();
    ScheduleSave();
  }

  protected override async Task OnAfterRenderAsync(bool firstRender) {
    if (firstRender) {
      await LoadFromLocalStorageAsync();
      currentText = GetCurrent();
      var module = await JS.InvokeAsync<IJSObjectReference>(
        "import", "./js/tinyMceHelper.js");
      await module.InvokeVoidAsync(
        "registerDotNetHelper",
        DotNetObjectReference.Create(this)
      );
      StateHasChanged();
    }
  }

  [JSInvokable]
  public Task LogEvent(string message) {
    eventLog.Insert(0, ($"{DateTime.Now:HH:mm:ss} {message}"));
    StateHasChanged();
    return Task.CompletedTask;
  }

  [JSInvokable]
  public Task OnEditorChange(string html) => LogEvent($"editorChange: content changed");

  [JSInvokable]
  public Task OnEditorBlur()    => LogEvent("editorBlur: lost focus");

  [JSInvokable]
  public Task OnEditorDirty()   => LogEvent("editorDirty: first change");

  private void ScheduleSave()
  {
    if (saveScheduled)
    {
      return;
    }

    var sinceLast = DateTime.UtcNow - lastSaveTime;
    var delay = sinceLast >= TimeSpan.FromSeconds(7)
        ? TimeSpan.Zero
        : TimeSpan.FromSeconds(7) - sinceLast;

    saveScheduled = true;
    saveCts = new CancellationTokenSource();
    _ = Task.Run(async () =>
    {
      try
      {
        await Task.Delay(delay, saveCts.Token);
        await InvokeAsync(SaveToLocalStorageAsync);
        lastSaveTime = DateTime.UtcNow;
      }
      catch (TaskCanceledException) { }
      finally
      {
        saveScheduled = false;
      }
    });
  }

  private async Task SaveToLocalStorageAsync()
  {
    await JS.InvokeVoidAsync("localStorage.setItem", KeyDocA, docA);
    await JS.InvokeVoidAsync("localStorage.setItem", KeyDocB, docB);
    await JS.InvokeVoidAsync("localStorage.setItem", KeyDocC, docC);
  }

  private async Task LoadFromLocalStorageAsync()
  {
    docA = await JS.InvokeAsync<string?>("localStorage.getItem", KeyDocA) ?? string.Empty;
    docB = await JS.InvokeAsync<string?>("localStorage.getItem", KeyDocB) ?? string.Empty;
    docC = await JS.InvokeAsync<string?>("localStorage.getItem", KeyDocC) ?? string.Empty;
  }

  public ValueTask DisposeAsync()
  {
    saveCts?.Cancel();
    return ValueTask.CompletedTask;
  }
}