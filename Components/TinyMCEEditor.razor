@using TinyMCE.Blazor
@inject IJSRuntime JS
@implements IAsyncDisposable
<div class="tiny-editor-wrapper">
    <Editor
        Id="articleEditor"
        ScriptSrc="libman/tinymce/tinymce.min.js"
        LicenseKey="gpl"
        JsConfSrc="myTinyMceConfig" />
</div>

@code {
    [Parameter]
    public EventCallback<string> ContentBlurred { get; set; }

    [Parameter]
    public EventCallback FirstChange { get; set; }

    [Parameter]
    public EventCallback Focused { get; set; }

    [Parameter]
    public EventCallback OnInit { get; set; }

    public bool IsReady { get; private set; }

    private DotNetObjectReference<TinyMCEEditor>? _objRef;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _objRef = DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("registerTinyEditorCallbacks", _objRef);
            IsReady = true;
            await OnInit.InvokeAsync();
        }
    }

    public async Task<string> GetContentAsync()
        => await JS.InvokeAsync<string>("getTinyEditorContent");

    public async Task<int> GetContentLengthAsync()
        => await JS.InvokeAsync<int>("getTinyEditorContentLength");

    public async Task SetContentAsync(string html)
        => await JS.InvokeVoidAsync("setTinyEditorContent", html);

    [JSInvokable]
    public async Task OnEditorBlur()
    {
        var content = await GetContentAsync();
        await ContentBlurred.InvokeAsync(content);
    }

    [JSInvokable]
    public Task OnEditorFocus()
        => Focused.InvokeAsync();

    [JSInvokable]
    public Task OnEditorDirty()
        => FirstChange.InvokeAsync();

    public ValueTask DisposeAsync()
    {
        _objRef?.Dispose();
        return ValueTask.CompletedTask;
    }
}
